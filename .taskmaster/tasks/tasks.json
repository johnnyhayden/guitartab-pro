{
  "master": {
    "tasks": [
      {
        "id": "1",
        "title": "Setup Project Repository",
        "description": "Initialize the project repository with version control and basic project structure.",
        "details": "Create a new Git repository for the project. Set up the basic directory structure for frontend and backend components. Initialize package managers for frontend (npm/yarn) and backend (pipenv/virtualenv).",
        "testStrategy": "Verify that the repository is accessible and the initial structure is correctly set up by cloning and running basic commands.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize Git repository and remote",
            "description": "Create the project root, initialize a Git repository with main branch, add baseline files (.gitignore, README, LICENSE), create/connect a remote repository, make the initial commit, and push.",
            "dependencies": [],
            "details": "- Create project directory and initialize Git: mkdir <project-name> && cd <project-name> && git init -b main\n- Create baseline files:\n  - README.md: include project name, summary, and high-level structure goals\n  - LICENSE: choose MIT or appropriate license\n  - .gitignore: include common Node, Python, and OS ignores (e.g., node_modules/, dist/, build/, .venv/, __pycache__/, .DS_Store, .env, .pytest_cache/)\n  - .gitattributes: text=auto eol=lf (optional)\n- Create and connect remote repo:\n  - Using GitHub CLI: gh repo create <org-or-user>/<repo> --public --source=. --remote=origin --push\n  - Or create manually on hosting provider, then: git remote add origin git@github.com:<org-or-user>/<repo>.git\n- First commit and push: git add . && git commit -m \"chore: initial repository setup\" && git push -u origin main\n- Configure repository settings (optional): default branch main, protect main branch, require PR reviews.",
            "status": "done",
            "testStrategy": "Run git remote -v to confirm remote connection. Visit the remote host to verify the repository exists and initial files are present. Optionally git clone <repo-url> ../tmp-clone and verify contents.",
            "parentId": "undefined",
            "updatedAt": "2025-09-26T21:55:32.307Z"
          },
          {
            "id": 2,
            "title": "Create base project directory structure",
            "description": "Establish a clear directory layout for frontend, backend, and project support assets to scaffold subsequent work.",
            "dependencies": [],
            "details": "- Create directories: mkdir -p frontend src placeholder if needed; mkdir -p backend; mkdir -p docs; mkdir -p scripts; mkdir -p .github/workflows\n- Add placeholder files so empty dirs are tracked: touch frontend/README.md backend/README.md docs/README.md scripts/README.md\n- Add an .editorconfig at repo root to enforce consistency (e.g., root=true; indent_size=2; end_of_line=lf; insert_final_newline=true)\n- Update README.md with a short directory layout section and contribution/getting started notes\n- Commit: git add . && git commit -m \"chore: scaffold base project structure\" && git push",
            "status": "done",
            "testStrategy": "List files (e.g., tree -a -L 2 or ls -la) and verify directories exist and are tracked. Confirm README includes the structure overview.",
            "parentId": "undefined",
            "updatedAt": "2025-09-26T21:57:26.904Z"
          },
          {
            "id": 3,
            "title": "Initialize frontend package manager (npm) and baseline configs",
            "description": "Set up Node.js tooling for the frontend with npm, add minimal lint/format configuration, and create placeholder source structure.",
            "dependencies": [],
            "details": "- Ensure Node.js LTS is available (e.g., nvm install --lts && nvm use; echo \"$(node -v)\" > frontend/.nvmrc)\n- Initialize npm in frontend: cd frontend && npm init -y\n- Create src and entry file: mkdir -p src && echo \"console.log('frontend initialized');\" > src/index.js\n- Add lint/format tooling: npm install -D eslint prettier eslint-config-prettier eslint-plugin-import\n- Create .eslintrc.json:\n  { \"env\": {\"browser\": true, \"es2021\": true, \"node\": true}, \"extends\": [\"eslint:recommended\", \"prettier\"], \"parserOptions\": {\"ecmaVersion\": 2021, \"sourceType\": \"module\"}, \"rules\": {} }\n- Create .prettierrc: {}\n- Add npm scripts to package.json: \"scripts\": { \"lint\": \"eslint \\\"src/**/*.js\\\"\", \"format\": \"prettier --write \\\"src/**/*.{js,json,md}\\\"\", \"format:check\": \"prettier --check \\\"src/**/*.{js,json,md}\\\"\" }\n- Commit: git add . && git commit -m \"chore(frontend): initialize npm and lint/format configs\" && git push\n- Note: If using Yarn instead of npm, run yarn init -y and replace npm commands accordingly.",
            "status": "done",
            "testStrategy": "From frontend/: run npm install to ensure dependencies install; run npm run lint and npm run format:check to confirm tooling works. Confirm src/index.js exists and no lint errors are reported.",
            "parentId": "undefined",
            "updatedAt": "2025-09-26T22:36:01.821Z"
          },
          {
            "id": 4,
            "title": "Initialize backend Python environment (pipenv) and baseline structure",
            "description": "Set up Python virtual environment with pipenv for the backend and create a minimal backend scaffolding.",
            "dependencies": [],
            "details": "- Ensure Python 3.11+ is available (e.g., pyenv install 3.11.x && pyenv local 3.11.x in backend/ if using pyenv)\n- Initialize pipenv in backend: cd backend && pipenv --python 3.11\n- Optionally add dev tools: pipenv install --dev black flake8 isort\n- Create basic structure: mkdir -p src/app && touch src/app/__init__.py && echo \"print('backend initialized')\" > src/app/main.py\n- Create config files (optional but recommended):\n  - .flake8 with basic rules (e.g., [flake8] max-line-length = 100; extend-ignore = E203,W503)\n  - pyproject.toml for Black/isort configuration (e.g., [tool.black] line-length = 100; [tool.isort] profile = \"black\")\n  - .env.example with placeholders (e.g., FLASK_ENV=development; DATABASE_URL=postgresql://user:pass@localhost:5432/db)\n- Add basic Makefile in backend/ with recipes: install (pipenv install --dev), fmt (pipenv run black . && pipenv run isort .), lint (pipenv run flake8)\n- Commit: git add . && git commit -m \"chore(backend): initialize pipenv and baseline structure\" && git push",
            "status": "done",
            "testStrategy": "From backend/: run pipenv run python src/app/main.py and verify output. If dev tools installed, run pipenv run black --version and pipenv run flake8 to confirm they execute.",
            "parentId": "undefined",
            "updatedAt": "2025-09-26T22:39:19.178Z"
          },
          {
            "id": 5,
            "title": "Configure pre-commit hooks and CI, then validate by cloning",
            "description": "Add repository-wide pre-commit hooks for basic hygiene and a CI workflow to verify installs for frontend and backend. Validate setup by cloning and running basic commands.",
            "dependencies": [],
            "details": "- Pre-commit setup (root):\n  - If using pipenv, install: cd backend && pipenv install --dev pre-commit && cd ..\n  - Create .pre-commit-config.yaml at repo root with hooks: trailing-whitespace, end-of-file-fixer, check-yaml, check-merge-conflict, mixed-line-ending; plus language-specific (optional): black, isort (repo: psf/black, PyCQA/isort), flake8; prettier (repo: pre-commit/mirrors-prettier, target frontend files)\n  - Install hooks: pre-commit install (run via pipenv: pipenv run pre-commit install from backend/ or use a global pre-commit install)\n- CI setup (GitHub Actions): create .github/workflows/ci.yml with two jobs on push/pull_request:\n  - frontend job: actions/setup-node@v4 (lts), working-directory: frontend, run: npm ci || npm install, then npm run lint and npm run format:check\n  - backend job: actions/setup-python@v5 (3.11), install pipenv, working-directory: backend, run: pipenv --python 3.11 && pipenv install --dev, then optional lint (pipenv run flake8)\n- Update README with CI status badge and local development instructions (frontend and backend basic commands)\n- Final validation by cloning fresh:\n  - In a separate directory: git clone <repo-url> fresh-clone && cd fresh-clone\n  - Run frontend check: cd frontend && npm install && npm run lint && cd ..\n  - Run backend check: cd backend && pipenv install --dev && pipenv run python src/app/main.py && cd ..\n  - Run pre-commit across repo: (from backend/) pipenv run pre-commit run --all-files",
            "status": "done",
            "testStrategy": "Open a pull request to trigger CI and confirm both jobs pass. Locally, verify pre-commit blocks malformed changes. Validate a fresh clone can install and run the basic commands without errors.",
            "parentId": "undefined",
            "updatedAt": "2025-09-26T22:42:28.341Z"
          },
          {
            "id": 6,
            "title": "Configure .gitignore, .gitattributes, and .editorconfig",
            "description": "Add standard ignore rules and text/line-ending normalization to ensure a clean, cross-platform repository.",
            "dependencies": [],
            "details": "Create a root-level .gitignore covering Python (.venv, venv, __pycache__, *.pyc, .pytest_cache, .mypy_cache, coverage/), Node (node_modules/, dist/, build/, .next/, coverage/), IDE/OS (.DS_Store, .idea/, .vscode/), env files (.env, .env.*), logs (*.log), and lockfiles as needed; add .gitattributes to enforce text eol=lf by default, mark common binaries (e.g., *.png, *.jpg, *.pdf) as binary, and set linguist settings if needed; add .editorconfig to standardize indentation (2 spaces for JS/TS/JSON/YAML, 4 spaces for Python), UTF-8, LF line endings, final newline, and trimming trailing whitespace.",
            "status": "done",
            "testStrategy": "Run `git check-ignore -v` on representative files to confirm ignore coverage; stage files with `git add -A` and verify no unwanted artifacts are tracked; confirm line endings with `git ls-files --eol`; ensure editors pick up .editorconfig by saving sample files.",
            "parentId": "undefined",
            "updatedAt": "2025-09-26T22:42:47.863Z"
          },
          {
            "id": 7,
            "title": "Initialize repository documentation and policies",
            "description": "Create foundational repo docs and community health files to guide contributors and clarify licensing.",
            "dependencies": [
              "1.6"
            ],
            "details": "Add README.md with project overview, architecture layout (frontend/backend), quick start, and development scripts; choose and add LICENSE (e.g., MIT) and note year/owner; add CONTRIBUTING.md (branching strategy, Conventional Commits, code style, PR process), CODE_OF_CONDUCT.md, and SECURITY.md (vulnerability reporting); create CHANGELOG.md with Keep a Changelog format; add .github/ISSUE_TEMPLATE (bug_report.yml, feature_request.yml) and .github/PULL_REQUEST_TEMPLATE.md; include status badges placeholders for CI and coverage.",
            "status": "done",
            "testStrategy": "Preview README locally to verify sections render; run a markdown linter (e.g., markdownlint) to ensure formatting; check that GitHub recognizes the license and templates by attempting to open a new issue/PR; verify links with a link checker.",
            "parentId": "undefined",
            "updatedAt": "2025-09-26T22:42:54.330Z"
          },
          {
            "id": 8,
            "title": "Create environment templates and bootstrap scripts",
            "description": "Provide reproducible setup via env templates and scripted bootstrapping for frontend and backend.",
            "dependencies": [
              "1.6"
            ],
            "details": "Add backend/.env.example (e.g., DATABASE_URL, JWT_SECRET, FLASK_ENV) and frontend/.env.example (e.g., VITE_API_BASE_URL or NEXT_PUBLIC_API_BASE_URL); add .nvmrc (Node 20.x) and .python-version (e.g., 3.11) for tooling consistency; create Makefile (or Taskfile) with targets: setup, backend.install, frontend.install, lint, format, test, run, clean; add scripts/bootstrap.sh (POSIX) and scripts/bootstrap.ps1 (Windows) to install Python env (virtualenv/pipenv), Node deps (npm ci or yarn install), and pre-commit; ensure package.json scripts exist for lint/test/build in frontend; commit lockfiles (Pipfile.lock/poetry.lock; package-lock.json/yarn.lock) if applicable.",
            "status": "done",
            "testStrategy": "From a fresh clone, run the bootstrap or `make setup` and verify: Python env created, dependencies installed, Node deps installed, and pre-commit installed; copy .env.example to .env for both apps and confirm commands `make lint` and `make test` run without errors; confirm Node and Python versions via the files are honored.",
            "parentId": "undefined",
            "updatedAt": "2025-09-26T22:42:54.359Z"
          },
          {
            "id": 9,
            "title": "Set up code quality and git hooks (pre-commit, linters, formatters, secret scan)",
            "description": "Configure automated formatting, linting, type checks, and secret scanning enforced via git hooks.",
            "dependencies": [
              "1.6",
              "1.8"
            ],
            "details": "Add .pre-commit-config.yaml with hooks: black, isort, ruff or flake8, trailing-whitespace, end-of-file-fixer, detect-secrets; configure pyproject.toml for black/isort/ruff settings; for frontend, add ESLint (.eslintrc) and Prettier (.prettierrc) with compatible rules; add npm scripts `lint`, `format`, and `lint:fix`; integrate commit message linting using @commitlint/config-conventional with a commit-msg hook (via pre-commit or Husky if needed); document usage in README; ensure CI can run the same checks.",
            "status": "done",
            "testStrategy": "Run `pre-commit run --all-files` to validate hooks; introduce intentionally misformatted files and ensure hooks fail and auto-fix where applicable; attempt a commit with a non-conforming message and confirm it is blocked; run `npm run lint` and Python linters to verify no errors.",
            "parentId": "undefined",
            "updatedAt": "2025-09-26T22:42:54.375Z"
          },
          {
            "id": 10,
            "title": "Configure CI workflows (GitHub Actions) for linting and tests",
            "description": "Add CI pipelines for backend and frontend to run on pushes/PRs with caching, artifacts, and coverage.",
            "dependencies": [
              "1.8",
              "1.9"
            ],
            "details": "Create .github/workflows/backend.yml to set up Python (3.11), install deps (cache pip), run pre-commit, unit tests, and upload coverage (e.g., to Codecov) on push/pull_request; create frontend.yml to set up Node (20.x), install deps with npm ci (cache), run lint, tests, and build; define concurrency groups and required checks for main branch; add status badges to README; optionally add a workflow to validate PR titles against Conventional Commits.",
            "status": "done",
            "testStrategy": "Open a draft PR to trigger workflows and verify all jobs pass; inspect workflow logs for cache hits and coverage upload; test a failing lint or test to ensure CI blocks merges; enable branch protection requiring the CI checks to pass before merging.",
            "parentId": "undefined",
            "updatedAt": "2025-09-26T22:42:54.391Z"
          }
        ],
        "updatedAt": "2025-09-26T22:42:54.391Z"
      },
      {
        "id": "2",
        "title": "Database Schema Design",
        "description": "Design and implement the PostgreSQL database schema for users, songs, and songlists.",
        "details": "Create tables for Users, Songs, Songlists, Songlist_Songs, and User_Preferences. Define primary keys, foreign keys, and necessary indexes. Use SQLAlchemy for ORM mapping in the backend.",
        "testStrategy": "Run database migration scripts and verify the schema using database inspection tools. Ensure all tables and relationships are correctly established.",
        "priority": "medium",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Requirements, ERD, and Naming Conventions",
            "description": "Capture detailed requirements, model entities/relations, and define schema/naming conventions.",
            "dependencies": [],
            "details": "Scope: Users, Songs, Songlists, Songlist_Songs (junction with position), User_Preferences (1:1 with Users).\nKey attributes:\n- users: id (uuid), email (citext), display_name (text), created_at, updated_at\n- songs: id (uuid), title (text), artist (text), album (text), duration_seconds (int), metadata (jsonb), created_at, updated_at\n- songlists: id (uuid), owner_id (uuid), name (text), description (text), is_public (bool), created_at, updated_at\n- songlist_songs: id (uuid), songlist_id (uuid), song_id (uuid), position (int), added_at (timestamptz)\n- user_preferences: user_id (uuid pk), prefs (jsonb), updated_at\nConventions:\n- snake_case table/column names; singular table names: users, songs, songlists, songlist_songs, user_preferences\n- Constraint/index naming: pk_<table>, fk_<table>__<col>__<reftable>, uq_<table>__<cols>, ix_<table>__<cols>, ck_<table>__<name>\n- Timestamps: timestamptz with default now(); app-managed onupdate for updated_at\nDeliverables: ERD diagram (PNG/DBML), conventions doc, attribute/type matrix.\nAcceptance criteria (data integrity): ERD reflects exact relationships (1:N users->songlists; M:N songlists<->songs via junction; 1:1 users->user_preferences). All required attributes and nullability documented; naming conventions approved and referenced by migrations/ORM.",
            "status": "done",
            "testStrategy": "",
            "updatedAt": "2025-09-26T22:46:19.543Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Alembic Base Setup and Migration Strategy",
            "description": "Initialize Alembic, configure metadata naming conventions, and define migration workflow.",
            "dependencies": [
              "2.1"
            ],
            "details": "Tasks:\n- alembic init, configure env.py to load SQLAlchemy Base.metadata with naming_convention\n- Enable required extensions via migration: CREATE EXTENSION IF NOT EXISTS pgcrypto; CREATE EXTENSION IF NOT EXISTS citext;\n- Strategy: one base schema revision (tables), followed by constraints/indexes if split is desired; always include downgrade paths\n- Autogenerate enabled; manual review required; migration IDs use message slugs\n- Envs: online/offline support; version_table schema default 'public'\nAcceptance criteria: alembic upgrade head and downgrade base succeed on fresh DB; naming_convention enforced; extensions created idempotently; CI job runs migrations without prompts.",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2025-09-26T22:49:09.777Z"
          },
          {
            "id": 3,
            "title": "Create Core Tables (DDL)",
            "description": "Author DDL migrations for Users, Songs, Songlists, Songlist_Songs, and User_Preferences.",
            "dependencies": [
              "2.1",
              "2.2"
            ],
            "details": "DDL (representative):\n- users: CREATE TABLE users (id uuid PRIMARY KEY DEFAULT gen_random_uuid(), email citext NOT NULL, display_name text, created_at timestamptz NOT NULL DEFAULT now(), updated_at timestamptz NOT NULL DEFAULT now());\n- songs: CREATE TABLE songs (id uuid PRIMARY KEY DEFAULT gen_random_uuid(), title text NOT NULL, artist text NOT NULL, album text, duration_seconds integer NOT NULL DEFAULT 0, metadata jsonb NOT NULL DEFAULT '{}'::jsonb, created_at timestamptz NOT NULL DEFAULT now(), updated_at timestamptz NOT NULL DEFAULT now());\n- songlists: CREATE TABLE songlists (id uuid PRIMARY KEY DEFAULT gen_random_uuid(), owner_id uuid NOT NULL, name text NOT NULL, description text, is_public boolean NOT NULL DEFAULT false, created_at timestamptz NOT NULL DEFAULT now(), updated_at timestamptz NOT NULL DEFAULT now());\n- songlist_songs: CREATE TABLE songlist_songs (id uuid PRIMARY KEY DEFAULT gen_random_uuid(), songlist_id uuid NOT NULL, song_id uuid NOT NULL, position integer NOT NULL, added_at timestamptz NOT NULL DEFAULT now());\n- user_preferences: CREATE TABLE user_preferences (user_id uuid PRIMARY KEY, prefs jsonb NOT NULL DEFAULT '{}'::jsonb, updated_at timestamptz NOT NULL DEFAULT now());\nAcceptance criteria (data integrity): All tables exist with columns and defaults as specified; no orphaned required columns left nullable; migration is reversible.",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2025-09-26T22:51:38.757Z"
          },
          {
            "id": 4,
            "title": "Constraints, Foreign Keys, and Cascade Rules",
            "description": "Define FKs, uniqueness, and check constraints with appropriate ON DELETE behavior.",
            "dependencies": [
              "2.3"
            ],
            "details": "Constraints:\n- users: UNIQUE (email)\n- songs: CHECK (duration_seconds >= 0)\n- songlists: FK owner_id -> users(id) ON DELETE CASCADE\n- songlist_songs: FK songlist_id -> songlists(id) ON DELETE CASCADE; FK song_id -> songs(id) ON DELETE CASCADE; CHECK (position >= 1); UNIQUE (songlist_id, song_id); UNIQUE (songlist_id, position)\n- user_preferences: FK user_id -> users(id) ON DELETE CASCADE; enforce 1:1 via PK\nOptional email format check: CHECK (email ~* '^[^@]+@[^@]+\\.[^@]+$')\nAcceptance criteria (data integrity): Inserting duplicates for unique columns fails; invalid positions or negative durations fail; deleting a user cascades to songlists and preferences; deleting songlists removes junction rows; deleting a song removes its junction rows; downgrade removes constraints cleanly.",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2025-09-26T22:51:38.792Z"
          },
          {
            "id": 5,
            "title": "Indexes (Unique, Search, and Query-Driven)",
            "description": "Create indexes to support uniqueness, filtering, and search patterns.",
            "dependencies": [
              "2.3",
              "2.4"
            ],
            "details": "Indexes:\n- users: CREATE UNIQUE INDEX uq_users__email ON users(email);\n- songs: CREATE INDEX ix_songs__title_artist ON songs (title, artist); CREATE INDEX ix_songs__search ON songs USING GIN (to_tsvector('simple', coalesce(title,'') || ' ' || coalesce(artist,'')));\n- songlists: CREATE INDEX ix_songlists__owner_public ON songlists (owner_id, is_public);\n- songlist_songs: CREATE INDEX ix_songlist_songs__song_id ON songlist_songs (song_id); (uniques defined in constraints)\nAcceptance criteria (performance): EXPLAIN on typical queries uses indexes (btree or gin); uniqueness enforced by index; no duplicate overlapping indexes; downgrade drops indexes.",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2025-09-26T22:51:38.807Z"
          },
          {
            "id": 6,
            "title": "SQLAlchemy Models and Relationships (with Type Hints)",
            "description": "Implement ORM models for all tables with relationships and typing.",
            "dependencies": [
              "2.3",
              "2.4",
              "2.5"
            ],
            "details": "Models (sketch):\n- Use Declarative with typing: from sqlalchemy.orm import Mapped, mapped_column, relationship\n- class User: id: Mapped[UUID]; email: Mapped[str]; display_name: Mapped[Optional[str]]; songlists: Mapped[list[Songlist]] = relationship(back_populates='owner', cascade='all, delete-orphan'); preferences: Mapped['UserPreferences'] = relationship(uselist=False, back_populates='user', cascade='all, delete-orphan')\n- class Song: id, title, artist, album, duration_seconds, metadata; songlists: Mapped[list['SonglistSong']] = relationship(back_populates='song', cascade='all, delete-orphan')\n- class Songlist: id, owner_id, name, ...; owner: relationship('User', back_populates='songlists'); items: Mapped[list['SonglistSong']] = relationship(back_populates='songlist', cascade='all, delete-orphan', order_by='SonglistSong.position')\n- class SonglistSong (association object): id, songlist_id, song_id, position, added_at; song: relationship('Song', back_populates='songlists'); songlist: relationship('Songlist', back_populates='items')\n- class UserPreferences: user_id PK, prefs (dict[str, Any]), updated_at; user: relationship('User', back_populates='preferences')\n- Configure __tablename__, indexes via __table_args__ to match naming_convention\nAcceptance criteria: ORM reflects DDL (columns, nullability, constraints). Relationship cascades align with FKs. Type hints pass mypy basic checks. SQLAlchemy can create and query relationships (add items with positions) without violating constraints.",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2025-09-26T22:51:38.822Z"
          },
          {
            "id": 7,
            "title": "Seed/Sample Data and Fixtures",
            "description": "Provide seed script and test fixtures with realistic sample data.",
            "dependencies": [
              "2.3",
              "2.6"
            ],
            "details": "Deliverables:\n- scripts/seed.py: inserts N users, M songs, K songlists; populates songlist_songs with unique (songlist_id, song_id) and sequential position; creates default user_preferences per user\n- Optional Alembic data revision for minimal bootstrap records (e.g., admin user)\n- Pytest fixtures: db_engine, db_session, seed_data factory for integration tests\nAcceptance criteria: Seed runs idempotently (clears or upserts as appropriate) in non-prod. All FKs and unique constraints satisfied. Basic queries return expected counts (e.g., each songlist has 5+ songs).",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2025-09-26T22:51:38.839Z"
          },
          {
            "id": 8,
            "title": "Validation and Migration Tests (Upgrade/Downgrade) + Performance Smoke",
            "description": "Write tests to validate schema integrity, migrations, and basic performance.",
            "dependencies": [
              "2.2",
              "2.3",
              "2.4",
              "2.5",
              "2.6",
              "2.7"
            ],
            "details": "Tests:\n- Migration cycle: upgrade -> seed -> downgrade -> upgrade; verify no residual objects\n- Integrity: uniques (users.email), checks (position>=1, duration>=0), FKs/cascades (deleting user cascades songlists/preferences; deleting songlist removes junction rows)\n- ORM: create/read/update/delete via models, relationship loading and ordering by position\n- Search index smoke: EXPLAIN analyze on title/artist search shows GIN index usage\n- Performance: On sample dataset (e.g., 10k songs), typical queries under 50ms on dev machine; no sequential scans for indexed filters\nAcceptance criteria: All tests pass in CI. Upgrade and downgrade succeed. EXPLAIN plans show index usage. Data integrity enforced by constraints and ORM prevents invalid state.",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2025-09-26T22:51:38.859Z"
          }
        ],
        "updatedAt": "2025-09-26T22:51:38.859Z"
      },
      {
        "id": "3",
        "title": "User Authentication System",
        "description": "Implement JWT-based user authentication with secure password handling.",
        "details": "Use Flask-JWT-Extended for JWT handling and bcrypt for password hashing. Implement registration, login, and password reset endpoints. Store user credentials securely in the database.",
        "testStrategy": "Write unit tests for authentication endpoints. Verify JWT tokens are issued and validated correctly. Test password hashing and storage security.",
        "priority": "high",
        "dependencies": [
          "2"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Security decisions: JWT lifetimes, rotation, and storage strategy",
            "description": "Define and document the core security configuration for JWT usage and token storage.",
            "dependencies": [],
            "details": "Decide and document:\n- JWT algorithm HS256 with a 256-bit SECRET_KEY from environment; include iss, sub, iat, nbf, exp, jti, and roles claims; 30s clock skew leeway.\n- Access token TTL: 15 minutes; Refresh token TTL: 7 days.\n- Refresh token rotation on every refresh; enable reuse detection and compromise response (revoke all existing refresh tokens for the user, require re-auth).\n- Token storage and transport: issue tokens in JSON response using Authorization: Bearer for clients; document guidance for web clients to prefer HttpOnly, Secure cookies if needed (server can optionally set cookies behind a flag).\n- Server-side revocation store: DB table for jti with indexes (user_id, jti, token_type, expires_at, revoked_at, reason); implement Flask-JWT-Extended callbacks to check revocation.\n- CORS and cookie settings: SameSite=Lax/Strict when cookies enabled, Secure and HttpOnly; restrict allowed origins.\nAcceptance Criteria:\n- A SECURITY.md and config module with the above decisions exist; all values configurable via env vars.\n- Tokens include jti and exp and are rejected when expired or revoked.\n- Storage strategy and rotation behavior are unambiguously specified for implementation and testing.",
            "status": "done",
            "testStrategy": "",
            "updatedAt": "2025-09-26T22:55:26.967Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Password policy and bcrypt configuration",
            "description": "Define password requirements and configure bcrypt hashing parameters.",
            "dependencies": [
              "3.1"
            ],
            "details": "Implement:\n- Password policy: min length 12; require uppercase, lowercase, digit, and special character; disallow email reuse; reject common passwords (use a lightweight top-10k list or zxcvbn score >= 3 if available).\n- Bcrypt configuration: bcrypt.gensalt(rounds=12) configurable via env; use constant-time comparisons; include per-hash salt from bcrypt.\n- Secure storage: store only bcrypt hashes; never store plaintext; ensure unique index on user email.\nAcceptance Criteria:\n- Creating a user stores a bcrypt hash (starts with $2) with configured cost.\n- Weak or common passwords are rejected with clear error messages.\n- Verification uses constant-time compare and passes unit tests.",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2025-09-26T22:55:26.988Z"
          },
          {
            "id": 3,
            "title": "Registration endpoint with email uniqueness and validation",
            "description": "Implement /auth/register with input validation and secure password handling.",
            "dependencies": [
              "3.1",
              "3.2"
            ],
            "details": "Implement POST /auth/register:\n- Request: { email, password, display_name? } with schema validation; normalize and validate email format.\n- Enforce email uniqueness (conflict returns 409) and rate-limit registrations per IP.\n- Hash password with bcrypt; store created_at/updated_at; default role=user.\n- Response: 201 with minimal user info (id, email, created_at); do not auto-issue tokens.\nAcceptance Criteria:\n- Duplicate emails return 409; invalid input returns 400 with field errors.\n- DB stores only bcrypt hashes; no plaintext secrets in logs.\n- Endpoint covered by unit tests.",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2025-09-26T22:55:27.002Z"
          },
          {
            "id": 4,
            "title": "Login endpoint with throttling/rate limiting and token issuance",
            "description": "Implement /auth/login with credential verification, rate limits, and JWT issuance.",
            "dependencies": [
              "3.1",
              "3.2",
              "3.3"
            ],
            "details": "Implement POST /auth/login:\n- Request: { email, password }.\n- Rate limits: e.g., 5/min per IP and 10/hour per account; exponential backoff on repeated failures.\n- On success: issue access and refresh tokens per security decisions; include roles claim; return JSON { access_token, refresh_token, expires_in }.\n- On failure: return 401 with generic message; use constant-time checks; log suspicious activity.\nAcceptance Criteria:\n- Tokens contain jti, exp, sub, and roles; validate via Flask-JWT-Extended.\n- Rate limits enforced and tested; successful login returns 200 with both tokens.\n- No sensitive error leakage (e.g., user enumeration).",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2025-09-26T22:55:27.015Z"
          },
          {
            "id": 5,
            "title": "Refresh, logout, and token revocation strategy implementation",
            "description": "Implement /auth/refresh, /auth/logout, and revocation checks with refresh rotation and reuse detection.",
            "dependencies": [
              "3.1",
              "3.4"
            ],
            "details": "Implement:\n- POST /auth/refresh: requires valid refresh token; rotate refresh token; persist new refresh jti; revoke old one; detect reuse and mark session compromised (revoke all tokens for user) and respond 401.\n- POST /auth/logout: revoke current access and refresh tokens; optionally provide /auth/logout-all to revoke all user tokens.\n- Revocation callbacks: integrate with Flask-JWT-Extended to check jti against revocation store for both access and refresh tokens.\n- Index revocation table for performance and TTL cleanup job.\nAcceptance Criteria:\n- Old refresh tokens cannot be reused after rotation (tested).\n- After logout, access token is rejected on protected endpoints; reuse detection triggers compromise workflow.\n- Revocation checks run on every authenticated request.",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2025-09-26T22:55:27.029Z"
          },
          {
            "id": 6,
            "title": "Password reset flow (email adapter) and change password endpoint",
            "description": "Implement secure password reset via emailed token and authenticated password change.",
            "dependencies": [
              "3.1",
              "3.2",
              "3.3"
            ],
            "details": "Implement:\n- POST /auth/request-password-reset: accept email; respond 200 regardless of existence; generate single-use, time-bound reset token (store hashed token with user_id, expires_at, used_at); send via email adapter interface; rate-limit requests.\n- POST /auth/reset-password: verify token and expiration; enforce password policy; update bcrypt hash; invalidate all active tokens for the user; delete/mark used reset tokens.\n- POST /auth/change-password (auth required): verify current password; enforce policy; update hash; revoke all tokens (require re-login).\nAcceptance Criteria:\n- No account enumeration via responses or timing.\n- Reset tokens are single-use, short-lived (e.g., 1 hour), and stored hashed; all user tokens revoked after password change/reset.\n- Flow covered by tests, including token expiry and replay rejection.",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2025-09-26T22:55:27.044Z"
          },
          {
            "id": 7,
            "title": "Role and claims scaffolding for future authorization",
            "description": "Add role storage and include claims in JWTs, plus basic decorators for role checks.",
            "dependencies": [
              "3.1",
              "3.3"
            ],
            "details": "Implement:\n- Extend user model to include role (e.g., user, admin) and optional custom claims field.\n- Inject roles claim into JWTs at issuance; add helper to refresh claims.\n- Provide @roles_required(['admin']) decorator and sample protected endpoint for demonstration.\nAcceptance Criteria:\n- Issued tokens contain roles claim; protected sample endpoint returns 403 for insufficient role and 200 for admin in tests.\n- Minimal migration and backfill strategy documented.",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2025-09-26T22:55:27.442Z"
          },
          {
            "id": 8,
            "title": "Tests: unit, integration, and threat-model checks",
            "description": "Comprehensive tests covering endpoints, token lifecycle, storage security, and abuse cases.",
            "dependencies": [
              "3.1",
              "3.2",
              "3.3",
              "3.4",
              "3.5",
              "3.6",
              "3.7"
            ],
            "details": "Implement tests with pytest and Flask test client:\n- Unit tests: validators, bcrypt hashing/verification, JWT claim contents, revocation lookup.\n- Integration tests: register/login/refresh/logout, rotation and reuse detection, password reset and change flows, role-protected routes, rate-limiting behavior (with time mocking), token expiry (freezegun).\n- Security checks: ensure no plaintext password storage, env-based secrets required, tokens rejected when expired/revoked, deny \"none\" algorithm.\n- Threat model checklist: enumerate key risks (token theft, fixation, replay, brute-force) and mitigation verification.\nAcceptance Criteria:\n- All tests pass in CI; coverage >= 85% for auth modules.\n- Explicit tests verify token issuance/validation and secure storage properties.",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2025-09-26T22:55:27.462Z"
          },
          {
            "id": 9,
            "title": "Documentation and client usage examples",
            "description": "Produce API docs, examples, and guidance for secure client token handling.",
            "dependencies": [
              "3.3",
              "3.4",
              "3.5",
              "3.6",
              "3.7"
            ],
            "details": "Deliverables:\n- OpenAPI/Swagger docs for /auth/register, /auth/login, /auth/refresh, /auth/logout, /auth/request-password-reset, /auth/reset-password, /auth/change-password.\n- Example flows (curl and Python) for registration, login, refresh rotation, logout-all, password reset, and role-protected access.\n- Token lifecycle diagram and guidance on storage (Authorization header vs HttpOnly cookies), error handling patterns, and rate-limit backoff.\n- Postman collection and README updates.\nAcceptance Criteria:\n- A developer can complete full auth flows using examples.\n- Docs clearly state token issuance/validation expectations and secure storage recommendations.",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2025-09-26T22:55:27.482Z"
          }
        ],
        "updatedAt": "2025-09-26T22:55:27.482Z"
      },
      {
        "id": "4",
        "title": "Basic Flask API Setup",
        "description": "Set up the core REST API endpoints for user and song management.",
        "details": "Create a Flask application with endpoints for CRUD operations on users and songs. Implement basic error handling and input validation.",
        "testStrategy": "Use Postman or similar tools to test API endpoints. Write integration tests to ensure endpoints function as expected.",
        "priority": "medium",
        "dependencies": [
          "3"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Application factory and environment-based configuration",
            "description": "Implement create_app with env-specific config and register core extensions.",
            "dependencies": [],
            "details": "Scope:\n- Add app factory: create_app(env=None) selecting DevelopmentConfig, TestingConfig, ProductionConfig via APP_ENV/FLASK_ENV.\n- Configure: SECRET_KEY, SQLALCHEMY_DATABASE_URI, SQLALCHEMY_TRACK_MODIFICATIONS=False, JWT_SECRET_KEY (from Task 3), JSON_SORT_KEYS=False, PROPAGATE_EXCEPTIONS=True, default pagination limits.\n- Initialize extensions: SQLAlchemy, Marshmallow, Flask-Migrate, CORS, logging (structured with request-id), and optionally JWT (do not enforce auth yet).\n- Set API base prefix '/api/v1'; add simple '/api/health' endpoint.\nDeliverables:\n- config.py with config classes; app/__init__.py with create_app; extensions.py for initialized instances; .env.example.\nAcceptance Criteria:\n- create_app returns a Flask app with correct env config (TestingConfig uses in-memory SQLite and TESTING=True).\n- App boots and GET /api/health returns 200 JSON {\"status\":\"ok\"}.\n- Extensions are registered without runtime errors; URL prefixing works for '/api/v1/*'.",
            "status": "done",
            "testStrategy": "",
            "updatedAt": "2025-09-26T22:59:02.855Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Blueprints for users and songs with routing conventions",
            "description": "Define versioned blueprints and RESTful routes for users and songs.",
            "dependencies": [
              "4.1"
            ],
            "details": "Scope:\n- Create blueprints: users_bp (prefix '/api/v1/users'), songs_bp (prefix '/api/v1/songs').\n- Define CRUD routes: GET '' (list), POST '' (create), GET '<int:id>' (retrieve), PUT/PATCH '<int:id>' (update), DELETE '<int:id>' (delete).\n- Establish route names (e.g., users.list_users) and consistent ID param naming ('user_id', 'song_id').\n- Register blueprints in create_app; provide temporary stub handlers returning JSON placeholders until CRUD is implemented in Subtask 4.7.\nDeliverables:\n- app/users/routes.py and app/songs/routes.py with route stubs and registration wiring.\n- Routing conventions doc (versioning, nouns, no verbs, plural resources).\nAcceptance Criteria:\n- URL map includes all listed routes under '/api/v1'.\n- Temporary stub responses return 200 JSON {\"status\":\"stub\"} for list/get and 501 for unimplemented mutations (to be finalized in Subtask 4.7).",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2025-09-26T22:59:02.873Z"
          },
          {
            "id": 3,
            "title": "Global error handlers with RFC 7807 problem+json responses",
            "description": "Centralize error handling and standardize JSON error contract.",
            "dependencies": [
              "4.1"
            ],
            "details": "Scope:\n- Implement error handlers for: HTTPException (use code), Marshmallow ValidationError (422), SQLAlchemy IntegrityError (409), NotFound (404), generic Exception (500).\n- Response format: application/problem+json with fields: type (URI), title, status, detail, instance (request path), correlation_id, and errors (field-level issues map) when applicable.\n- Add request ID middleware (X-Request-ID; generate if missing) and include in logs and error responses.\n- Map unknown routes to 404 problem+json.\nDeliverables:\n- app/errors.py with handler registrations; middleware to attach correlation_id; documentation of error contract with examples.\nAcceptance Criteria:\n- Any raised HTTPException returns application/problem+json with correct status and headers.\n- Validation errors produce 422 with errors map; IntegrityError returns 409 with conflict detail.\n- Responses include correlation_id and instance; content-type is application/problem+json.",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2025-09-26T22:59:02.888Z"
          },
          {
            "id": 4,
            "title": "Input validation schemas and response models",
            "description": "Create Marshmallow schemas for users/songs and decorators to validate/serialize.",
            "dependencies": [
              "4.1",
              "4.2",
              "4.3"
            ],
            "details": "Scope:\n- Schemas: UserCreate(email, username, password), UserUpdate(optional fields), UserOut(id, email, username, created_at); SongCreate(title, artist, tuning?, difficulty?), SongUpdate, SongOut(id, title, artist, created_at).\n- Constraints: email format, username [a-z0-9_]{3,30}, password length>=8, title required; coerce/strip strings.\n- List envelope schema: { items: [...], meta: { page, per_page, total, pages, sort, order } }.\n- Implement decorators/helpers: validate_request(schema) -> parsed data on g; serialize_response(schema or envelope) -> consistent output.\n- Ensure sensitive fields (password) never serialized in responses.\nDeliverables:\n- app/schemas/user.py, app/schemas/song.py; app/utils/validation.py decorators; schema docs.\nAcceptance Criteria:\n- Invalid payloads yield 422 problem+json with field-level errors; valid payloads pass data to handlers.\n- Successful responses conform to output schemas; no password or sensitive data in any response.",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2025-09-26T22:59:02.904Z"
          },
          {
            "id": 5,
            "title": "Pagination and sorting utilities",
            "description": "Implement reusable helpers for page/per_page and sorting with validation.",
            "dependencies": [
              "4.1",
              "4.2",
              "4.3",
              "4.4"
            ],
            "details": "Scope:\n- Helper parse_pagination(args, defaults): supports page>=1, per_page [1..100], defaults from config.\n- Sorting: parse_sort(args, allowed_fields) supporting 'sort' and 'order' or a '-field' syntax; validate allowed fields per resource.\n- SQLAlchemy integration: apply_pagination(query) returning items and total; build Link header (first, prev, next, last) and meta object.\n- Validation errors surface via problem+json (422) with clear messages; unknown sort fields rejected.\nDeliverables:\n- app/utils/pagination.py with parsing, SQLAlchemy helpers, and header/meta builders; usage examples in docstrings.\nAcceptance Criteria:\n- GET list endpoints can pass page/per_page/sort/order to helpers and receive consistent meta and Link headers.\n- Invalid pagination/sort inputs return 422 problem+json with errors map; defaults apply when params omitted.",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2025-09-26T22:59:02.916Z"
          },
          {
            "id": 6,
            "title": "OpenAPI/Swagger documentation with CI validation",
            "description": "Generate and serve OpenAPI spec and validate it in CI.",
            "dependencies": [
              "4.1",
              "4.2",
              "4.3",
              "4.4",
              "4.5"
            ],
            "details": "Scope:\n- Define OpenAPI 3.0 spec (openapi.yaml/json) using apispec + Marshmallow schemas; include servers, tags (Users, Songs), components/schemas, and shared Problem+JSON error schema.\n- Annotate routes with operationIds, parameters (pagination/sort), request bodies, and standardized responses (200, 201 with Location, 204, 400/422/404/409 via problem+json).\n- Serve /api/openapi.json and Swagger UI at /api/docs.\n- CI: add job to validate spec with openapi-spec-validator and Spectral lint; fail build on errors.\nDeliverables:\n- docs/openapi.yaml; app/docs.py serving spec and docs; CI workflow config (e.g., .github/workflows/openapi-validate.yml).\nAcceptance Criteria:\n- GET /api/openapi.json returns a valid spec; Swagger UI loads with no console errors.\n- CI validation passes on main and PRs; error responses documented consistently across endpoints.",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2025-09-26T22:59:02.931Z"
          },
          {
            "id": 7,
            "title": "Test harness (pytest fixtures, client) and minimal CRUD skeletons",
            "description": "Add pytest setup and implement minimal working CRUD for users and songs.",
            "dependencies": [
              "4.1",
              "4.2",
              "4.3",
              "4.4",
              "4.5",
              "4.6"
            ],
            "details": "Scope:\n- Pytest setup: conftest.py with app(), client(), db() fixtures using TestingConfig; factory for sample users/songs; transactional test isolation.\n- Implement CRUD handlers using SQLAlchemy models (from Task 2) + schemas + pagination utilities:\n  - Users: POST create (201, Location), GET list (200 + meta + Link), GET by id (200/404), PATCH/PUT update (200/404), DELETE (204/404). Exclude password from responses.\n  - Songs: same pattern; define allowed sort fields.\n- Negative cases: validation 422, conflict 409 on unique constraints, not found 404, bad pagination/sort 422; all errors follow problem+json contract.\n- Optional: protect write operations with JWT (Task 3) behind a feature flag; tests can run without auth.\n- Coverage and run scripts.\nDeliverables:\n- Implemented route handlers replacing stubs; tests under tests/api/test_users.py and tests/api/test_songs.py; coverage config (>=80%).\nAcceptance Criteria:\n- All tests pass locally and in CI; coverage >=80% for app package.\n- Endpoints behavior:\n  - Create returns 201 with Location header pointing to resource URI and body matching *Out schema.\n  - List returns 200 with items[] and meta; Link header present when applicable.\n  - Get returns 200 with resource or 404 problem+json if missing.\n  - Update returns 200 with updated resource; partial updates accepted for PATCH.\n  - Delete returns 204 with empty body.\n- Error contract: application/problem+json with fields {type,title,status,detail,instance,correlation_id,errors?} for all error responses.",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2025-09-26T22:59:02.945Z"
          }
        ],
        "updatedAt": "2025-09-26T22:59:02.945Z"
      },
      {
        "id": "5",
        "title": "Frontend Framework Initialization",
        "description": "Initialize the frontend using a modern JavaScript framework (Vue.js or React).",
        "details": "Set up a new project using Vue CLI or Create React App. Configure routing and state management (Vuex or Redux). Implement a basic responsive layout.",
        "testStrategy": "Verify the frontend builds and runs without errors. Test routing and state management through browser testing.",
        "priority": "medium",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Framework selection and project scaffold",
            "description": "Decide between React or Vue and initialize the frontend using Vite (preferred) or CRA/Vue CLI.",
            "dependencies": [],
            "details": "Decide: React+Vite or Vue+Vite/CLI based on team expertise, ecosystem needs, and planned UI libraries. Initialize project (TypeScript recommended). Example commands: npm create vite@latest frontend -- --template react-ts or --template vue-ts; alternatively npx create-react-app frontend --template typescript or vue create frontend. Set package manager (npm/yarn/pnpm), add .gitignore, README, and basic src structure (components, pages, store, styles). Verify dev server and production build run. Acceptance checks: npm run dev shows starter page; npm run build completes without errors; initial structure committed.",
            "status": "done",
            "testStrategy": "",
            "updatedAt": "2025-10-04T13:19:13.623Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Routing setup and basic pages",
            "description": "Install and configure routing with base pages and a 404 route.",
            "dependencies": [
              "5.1"
            ],
            "details": "Install router: React -> npm i react-router-dom; Vue -> npm i vue-router. Configure routes: '/', '/songs' (placeholder), '/about', and a catch-all 404. Create pages: Home, SongsPlaceholder, About, NotFound. Add a simple navigation header linking routes; enable history mode. Optional: code-split routes. Acceptance checks: navigating via links and direct URL loads the correct page without console errors; unknown route shows 404; minimal smoke test for Home page passes with npm run test.",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2025-10-04T13:22:54.569Z"
          },
          {
            "id": 3,
            "title": "State management baseline",
            "description": "Set up a global store (Redux Toolkit for React or Pinia/Vuex for Vue) with an initial slice/module.",
            "dependencies": [
              "5.1",
              "5.2"
            ],
            "details": "React: npm i @reduxjs/toolkit react-redux; Vue: npm i pinia (or vuex if required). Create store with an app slice/module (e.g., ui flags) and an auth placeholder. Wire Provider into app root and expose typed hooks (React) or usePinia() (Vue). Add an example async action to fetch a backend health/config using API URL env. Enable devtools. Acceptance checks: a button on Home toggles/increments state via dispatch and reflects across routes; reducer/unit test passes; no type errors; npm run test succeeds.",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2025-10-04T13:30:00.842Z"
          },
          {
            "id": 4,
            "title": "UI layout, theme, and responsive grid",
            "description": "Implement responsive app shell with base theme tokens and grid.",
            "dependencies": [
              "5.1",
              "5.2"
            ],
            "details": "Choose styling approach: Tailwind CSS or CSS Modules/SCSS (optionally a component library like MUI/Chakra/Element Plus). Create AppShell with header, nav, main content, and footer; implement responsive grid/containers and mobile nav. Define theme tokens (colors, spacing, typography) via CSS variables or library theme config. Ensure basic accessibility (landmarks, focus styles). Acceptance checks: layout adapts correctly on mobile/tablet/desktop; no horizontal scroll on common breakpoints; lighthouse performance/accessibility reasonable (>=80); visual smoke check passes.",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2025-10-04T13:31:35.646Z"
          },
          {
            "id": 5,
            "title": "Lint, format, and test tooling with scripts",
            "description": "Configure ESLint, Prettier, and unit testing (Jest/Vitest) with useful npm scripts and pre-commit hooks.",
            "dependencies": [
              "5.1"
            ],
            "details": "Install and configure ESLint + Prettier (+ TypeScript plugins); add .editorconfig. Set up unit tests: Vitest (Vite) or Jest; React Testing Library or Vue Test Utils for component tests. Add scripts: dev, build, preview, lint, lint:fix, format, test, test:watch, type-check. Optional: Husky + lint-staged to run lint/test on pre-commit. Acceptance checks: npm run lint passes; npm run test passes with at least one component and one reducer/module test; formatting consistent; pre-commit hook blocks on errors (if enabled).",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2025-10-04T13:27:14.097Z"
          },
          {
            "id": 6,
            "title": "CI pipeline and environment variables handling",
            "description": "Set up CI to run install/lint/test/build and standardize environment variables for dev/prod.",
            "dependencies": [
              "5.1",
              "5.5"
            ],
            "details": "Create CI workflow (e.g., GitHub Actions) to cache deps and run: install, npm run lint, npm run test, npm run build; upload build artifact. Add .env.example and environment files (.env.development, .env.production). Use Vite envs (VITE_API_URL) or framework-specific prefixes (REACT_APP_/VUE_APP_). Implement configuration loader with runtime guard for required envs and document usage in README. Acceptance checks: CI passes on PRs; local dev reads .env.development; production build uses .env.production; missing required env surfaces a clear error; npm run build succeeds in CI.",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2025-10-04T13:36:05.314Z"
          },
          {
            "id": 7,
            "title": "Framework selection and project scaffold",
            "description": "Choose React or Vue and initialize the frontend project scaffold with Vite (preferred) or CRA/Vue CLI.",
            "dependencies": [],
            "details": "Decide framework and tooling: React (with TypeScript) or Vue 3 (with TypeScript); prefer Vite for faster DX. Set Node version (e.g., .nvmrc) and package manager (npm or yarn). For React (Vite): npm create vite@latest frontend -- --template react-swc-ts. For Vue (Vite): npm create vite@latest frontend -- --template vue-ts. Alternatives: React (CRA): npx create-react-app frontend --template typescript. Vue CLI: npm i -g @vue/cli && vue create frontend (select TS). Initialize repository if needed and commit scaffold. Verify commands: npm install; npm run dev (app serves locally without errors); npm run build (build completes). Acceptance: dev server renders default page, build succeeds, initial commit pushed.",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2025-10-04T13:22:05.659Z"
          },
          {
            "id": 8,
            "title": "Routing setup and basic pages",
            "description": "Add client-side routing and create basic pages (Home, About, Not Found) with a shared layout.",
            "dependencies": [
              "5.7"
            ],
            "details": "Install router: React: npm i react-router-dom@6. Vue: npm i vue-router@4. Create pages/views: Home, About, NotFound. Define routes with lazy-loaded components and a catch-all 404 route. Add a simple Layout (header/nav/main/footer) with navigation links. Enable deep-link refresh handling (BrowserRouter for React, history mode for Vue). Manual checks: navigate via links, use back/forward, direct-load nested route; 404 renders for unknown path. Commands: npm run dev (routes function), npm run build (router compiles). Acceptance: navigation works across pages and 404, no console errors in dev, build succeeds.",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2025-10-04T13:27:52.792Z"
          },
          {
            "id": 9,
            "title": "State management baseline",
            "description": "Introduce a global store and wire it to the app with a simple slice/module and example usage.",
            "dependencies": [
              "5.7"
            ],
            "details": "Pick library: React: npm i @reduxjs/toolkit react-redux; Vue: npm i pinia (or vuex@next if required). Initialize store and provider: React: configureStore and <Provider store={store}> in main entry. Vue: createPinia() and app.use(pinia). Create a basic slice/module (e.g., ui/theme with toggle). Connect a component to read and update state (theme toggle). Add devtools integration (Redux DevTools or Pinia devtools). Acceptance: toggling updates UI state in the page; no runtime errors; later when tests are set up, a unit test validates initial state and a reducer/action updates state as expected.",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2025-10-04T13:29:08.625Z"
          },
          {
            "id": 10,
            "title": "UI layout, theme, and responsive grid",
            "description": "Implement a responsive base layout with theme variables and grid/flex utilities.",
            "dependencies": [
              "5.7",
              "5.9"
            ],
            "details": "Choose styling approach: Tailwind CSS (recommended) or CSS Modules/SCSS. Tailwind setup (Vite): npm i -D tailwindcss postcss autoprefixer && npx tailwindcss init -p; configure content paths and include Tailwind in main CSS. Define CSS variables for light/dark theme and connect to state (theme toggle from store). Build responsive layout: header with brand, nav, main content container, footer; mobile-first with breakpoints; ensure accessible skip link and focus styles. Add basic grid/flex utilities for content areas. Manual checks at widths 360px, 768px, 1024px+: no horizontal scroll, nav collapses/works, contrasts meet WCAG AA. Commands: npm run dev (responsive works), npm run build. Acceptance: layout adapts across breakpoints, theme toggle updates styles, build succeeds with no CSS errors.",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2025-10-04T13:41:21.880Z"
          },
          {
            "id": 11,
            "title": "Lint, format, tests, and project scripts",
            "description": "Configure ESLint, Prettier, and testing (Vitest/Jest + Testing Library) with npm scripts and pre-commit hooks.",
            "dependencies": [
              "5.7"
            ],
            "details": "Install and configure ESLint + Prettier. React: npm i -D eslint @typescript-eslint/parser @typescript-eslint/eslint-plugin eslint-plugin-react eslint-plugin-react-hooks eslint-config-prettier prettier. Vue: npm i -D eslint @typescript-eslint/parser @typescript-eslint/eslint-plugin eslint-plugin-vue eslint-config-prettier prettier. Add .eslintrc and .prettierrc; ignore files as needed. Testing: prefer Vitest + jsdom. React: npm i -D vitest @vitest/coverage-v8 jsdom @testing-library/react @testing-library/user-event @testing-library/jest-dom. Vue: npm i -D vitest @vitest/coverage-v8 jsdom @testing-library/vue @testing-library/user-event @testing-library/jest-dom. Configure vitest in vite.config or vitest.config. Add example tests for Home page and store (if React: reducer test; if Vue: store action). Add scripts: \"dev\", \"build\", \"preview\", \"lint\", \"lint:fix\", \"format\", \"test\", \"test:watch\", \"coverage\", and optionally \"type-check\". Set up Husky + lint-staged for pre-commit: npm i -D husky lint-staged && npx husky init; configure pre-commit to run lint-staged and tests on changed files. Acceptance: npm run lint passes, npm run test passes with coverage report, pre-commit hook runs successfully on staged changes.",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2025-10-04T13:29:53.549Z"
          },
          {
            "id": 12,
            "title": "CI workflow and environment variables handling",
            "description": "Create CI pipeline to run install/lint/test/build and standardize environment variable management.",
            "dependencies": [
              "5.7",
              "5.11"
            ],
            "details": "Set up GitHub Actions workflow (.github/workflows/ci.yml). Steps: checkout, setup-node (LTS), dependency cache, install, run lint, type-check (if enabled), tests with coverage, and build; upload dist as artifact. Matrix Node versions if needed. Add .env.example with documented variables: Vite uses VITE_* (e.g., VITE_API_BASE_URL); CRA uses REACT_APP_*; gitignore .env*. Load env in code via import.meta.env.VITE_* (Vite) or process.env.REACT_APP_*. Document env usage in README and how to run locally (npm run dev) with .env. For preview deployments (optional), add a deploy job (e.g., to Vercel/Netlify) consuming env from repo secrets. Acceptance: CI passes on PRs (install, lint, test, build all succeed), build artifact generated, env variables are not committed, app reads expected env at runtime in dev and after build.",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2025-10-04T13:42:26.568Z"
          }
        ],
        "updatedAt": "2025-10-04T13:42:26.568Z"
      },
      {
        "id": "6",
        "title": "Song CRUD Operations",
        "description": "Implement create, read, update, and delete operations for songs in the backend.",
        "details": "Develop API endpoints for song CRUD operations. Ensure proper validation and error handling. Integrate with the database using SQLAlchemy.",
        "testStrategy": "Write unit and integration tests for each CRUD operation. Verify database changes through direct inspection.",
        "priority": "medium",
        "dependencies": [
          "4"
        ],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "Define DTOs/Schemas for Song Input/Output",
            "description": "Create Marshmallow schemas for SongCreate, SongUpdate, SongOut, and ListQueryParams with field constraints and defaults.",
            "dependencies": [],
            "details": "Fields and constraints:\n- SongCreate: title (str, 1-200, required), artist (str, 1-120, required), album (str, 0-160, optional), duration_seconds (int, 1..36000, required), release_date (date, optional, not in future), genre (str, 0-60, optional), is_public (bool, default true).\n- SongUpdate: partial=True; same fields as SongCreate except all optional. Prevent updates to immutable fields like id, owner_id, created_at.\n- SongOut: id, owner_id, title, artist, album, duration_seconds, release_date, genre, is_public, created_at, updated_at.\n- ListQueryParams: page (int, >=1, default 1), per_page (int, 1..100, default 25), sort_by (enum: title|artist|created_at, default created_at), sort_order (enum: asc|desc, default desc), filters: title (str), artist (str), genre (str), owner_id (int), is_public (bool), scope (enum: public|mine|all; optional; for auth-aware listing).\nAcceptance criteria:\n- Schemas perform validation, deserialization, and serialization with correct types and defaults applied.\n- Unknown fields are rejected with clear error messages.\n- SongOut serializes datetime fields in ISO 8601.\n- ListQueryParams enforces allowed sort_by and sort_order values.\n<info added on 2025-10-04T13:46:16.511Z>\n- Implemented Pydantic-based DTOs/schemas:\n  - SongCreateSchema (validates required fields)\n  - SongUpdateSchema (partial updates; blocks immutable fields: id, owner_id, created_at)\n  - SongResponseSchema (complete output model with id, owner_id, title, artist, album, duration_seconds, release_date, genre, is_public, created_at, updated_at)\n  - SongListResponseSchema (paginated response: items, page, per_page, total, pages)\n  - SongQueryParams (page >= 1 default 1; per_page 1..100 default 25; sort_by in title|artist|created_at default created_at; sort_order in asc|desc default desc; filters: title, artist, genre, owner_id, is_public; scope in public|mine|all)\n- Validation and behavior:\n  - Enforces field length limits, duration_seconds range (1..36000), and release_date not in the future\n  - Rejects unknown/extra fields with clear error messages (extra = forbid)\n  - Datetime fields serialize to ISO 8601\n  - Proper type hints with UUID for id and owner_id\n  - URL fields (if present) validated for HTTP/HTTPS format\n  - Optional content fields (lyrics, chords, tab) limited to 50KB each\n  - Field descriptions and examples included for documentation\n  - ORM integration enabled (orm_mode) for SQLAlchemy compatibility\n- Files added:\n  - Module initialization for the schemas package\n  - Complete schema definitions module for songs\n</info added on 2025-10-04T13:46:16.511Z>",
            "status": "done",
            "testStrategy": "",
            "updatedAt": "2025-10-04T13:46:20.438Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Service/Repository Layer with SQLAlchemy",
            "description": "Create repository and service functions to manage Song persistence and business rules.",
            "dependencies": [
              "6.1"
            ],
            "details": "Implement functions (with type-hinted signatures):\n- create_song(data: SongCreate, owner_id: int) -> Song\n- get_song(song_id: int) -> Song (or raise NoResultFound)\n- list_songs(filters, pagination, sorting, viewer) -> (items, total)\n- update_song(song_id: int, data: SongUpdate, actor) -> Song\n- delete_song(song_id: int, actor) -> None\nRepository/service responsibilities:\n- Use SQLAlchemy sessions with proper transaction boundaries and rollback on exceptions.\n- Eager-load relationships needed by API serialization to avoid N+1 queries.\n- Enforce updated_at timestamps on update.\n- Handle IntegrityError and map to higher-level errors for the API layer.\n- Ensure delete removes the song and cascades/removes any Songlist_Songs associations per existing schema configuration.\nAcceptance criteria:\n- Creating a song returns a persisted entity with an assigned id and timestamps.\n- Updating changes are committed and reflected when reloaded; updated_at changes.\n- Deleting removes row from DB and related associations per schema; subsequent fetch raises NoResultFound.\n- list_songs supports filters, pagination, and sorting inputs (to be extended in subtask 5) and returns total count.\n<info added on 2025-10-04T13:48:03.175Z>\n- Implemented BaseService and SongService classes with type-hinted CRUD methods: create_song, get_song, list_songs, update_song, delete_song.\n- Added filtering, pagination, and sorting to list_songs, returning (items, total).\n- Enforced ownership verification for update and delete operations; unauthorized actions raise a service-level PermissionDenied error.\n- Managed SQLAlchemy sessions with explicit transaction boundaries; commit on success and rollback on exceptions.\n- Eager-loaded required relationships for API serialization to prevent N+1 queries.\n- Ensured updated_at is set on every modification.\n- Handled IntegrityError and mapped to higher-level Conflict/Validation errors for the API layer.\n- Deletion respects cascade rules; related Songlist_Songs associations are removed per schema.\n- All modules compile successfully.\n</info added on 2025-10-04T13:48:03.175Z>",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2025-10-04T13:48:06.341Z"
          },
          {
            "id": 3,
            "title": "Build Song CRUD API Endpoints",
            "description": "Expose Flask endpoints for create, read (single/list), update, and delete operations.",
            "dependencies": [
              "6.1",
              "6.2"
            ],
            "details": "Endpoints (Flask Blueprint /songs):\n- POST /songs: Auth required. Body: SongCreate. Returns 201 with SongOut and Location header /songs/{id}.\n- GET /songs/{id}: Returns 200 with SongOut if accessible (see auth rules). 404 if not found, 403 if forbidden.\n- GET /songs: Supports ListQueryParams for pagination/filtering/sorting. Returns 200 with {items: [SongOut], meta: {page, per_page, total, total_pages, sort_by, sort_order, filters}}.\n- PATCH /songs/{id}: Auth required. Body: SongUpdate (partial). Returns 200 with SongOut.\n- DELETE /songs/{id}: Auth required. Returns 204 with empty body.\nGeneral:\n- Consistent JSON response shapes; no HTML error pages.\n- Content-Type application/json enforced where applicable.\nAcceptance criteria:\n- Each endpoint wired to service layer and schemas, returning correct HTTP status codes and payloads.\n- Location header set on create; PATCH idempotent for repeated same payloads.\n- Unsupported methods return 405.\n<info added on 2025-10-04T13:51:09.845Z>\n- Implemented Flask-RESTX namespace (songs_ns) under /api/songs with routes:\n  - POST /api/songs (auth) — creates song; returns 201 with SongOut and Location: /api/songs/{id}\n  - GET /api/songs — lists songs with filtering/sorting/pagination; returns {items, meta}\n  - GET /api/songs/{id} — public; returns SongOut and increments view count\n  - PUT /api/songs/{id} (auth, owner) — updates song (idempotent)\n  - DELETE /api/songs/{id} (auth, owner) — deletes song; returns 204\n  - GET /api/songs/user (auth) — returns current user’s songs\n  - POST /api/songs/{id}/rate (auth) — rate a song\n- JWT authentication applied to protected endpoints; ownership verification enforced for update/delete.\n- Request validation via Marshmallow schemas (bodies and query params); automatic API documentation through Flask-RESTX.\n- Consistent JSON responses with Content-Type application/json; centralized error handling returning 400, 401, 403, 404, 409, 422, 500; 405 for unsupported methods.\n- Endpoints wired to service/repository layer and schemas; correct HTTP status codes and payloads; no HTML error pages.\n- Registered songs_ns with the main app and updated API root to include songs URLs.\n- Code compiles successfully and is ready for testing.\n</info added on 2025-10-04T13:51:09.845Z>",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2025-10-04T13:52:45.810Z"
          },
          {
            "id": 4,
            "title": "Integrate Validation and Centralized Error Mapping",
            "description": "Apply schema validation and implement a unified error handler to map exceptions to API errors.",
            "dependencies": [
              "6.1",
              "6.2",
              "6.3"
            ],
            "details": "Validation:\n- Use Marshmallow to load and validate request bodies and query params; reject unknown fields.\nError handling:\n- Central handler mapping:\n  - Schema validation errors -> 422 Unprocessable Entity with {error: {code: \"validation_error\", message, details: {field: [messages]}}}.\n  - SQLAlchemy NoResultFound -> 404 Not Found with code \"not_found\".\n  - IntegrityError -> 409 Conflict with code \"conflict\" and DB constraint info (redacted/safe).\n  - JWT/authorization failures -> 401 Unauthorized or 403 Forbidden with codes \"unauthorized\"/\"forbidden\".\n  - Malformed JSON -> 400 Bad Request with code \"bad_request\".\n- Ensure consistent error envelope and correlation id logging.\nAcceptance criteria:\n- Invalid payloads and query params yield 422 with field-level messages.\n- Missing/invalid JWT yields 401 with WWW-Authenticate header.\n- Forbidden operations yield 403; non-existent resources yield 404.\n- Integrity errors yield 409; responses never expose raw SQL or stack traces in production mode.",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2025-10-04T14:03:11.614Z"
          },
          {
            "id": 5,
            "title": "Add Pagination, Filtering, and Sorting Primitives",
            "description": "Implement safe query building for list endpoint with pagination, filters, and sortable columns.",
            "dependencies": [
              "6.1",
              "6.2",
              "6.3",
              "6.4"
            ],
            "details": "Capabilities:\n- Pagination: page/per_page via offset/limit; cap per_page at 100; include total and total_pages.\n- Sorting: whitelist columns [title, artist, created_at]; support asc/desc; default created_at desc; stable ordering.\n- Filtering: title and artist case-insensitive substring (ILIKE %q%), genre exact match, owner_id exact, is_public boolean.\n- Query builder composes filters and sorting safely (no SQL injection), leveraging SQLAlchemy column references.\nAcceptance criteria:\n- GET /songs returns correct counts and items for various page/per_page inputs and includes meta fields.\n- Sorting order is applied as requested; invalid sort fields/order rejected via 422.\n- Filters reduce result set appropriately and can be combined with pagination.\n- Performance: listing executes a bounded number of queries (no N+1), and COUNT is accurate.\n<info added on 2025-10-04T14:07:04.454Z>\nEnhancements:\n- Added pagination.py with PaginationInfo, PaginatedResult, AdvancedPagination (offset and cursor), PaginationBuilder, and PageCache (LRU). Cursor-based pagination enables efficient traversal with stable ordering; offset-based pagination continues to support page/per_page (capped at 100) with total and pages.\n- Extended filter primitives to support user scope (owner_id, is_public), genre, title/artist ILIKE, and numeric range filters for difficulty, year, and rating. Cross-field validation rejects ranges where min > max.\n- Introduced schemas to support advanced querying and operations: SongQueryParams, AdvancedSearchParams, BulkUpdateSchema, BulkDeleteSchema, and FilterOptionsSchema.\n- Added specialized query builders: get_popular_songs (views desc), get_top_rated_songs (rating desc), get_recent_songs (created_at desc), plus artist- and genre-scoped retrieval with pagination.\n- Implemented transactional bulk operations (bulk update/delete) using whitelisted columns and safe SQLAlchemy expressions.\n- Exposed endpoints powered by these primitives: /songs/popular, /songs/top-rated, /songs/recent, /songs/filter-options, /songs/advanced-search, /songs/bulk-update, /songs/bulk-delete, /songs/artist/<name>, /songs/genre/<name>.\n- Performance: all filtering/sorting is database-level; optional cursor mode for large datasets; bounded query count with no N+1; LRU caching for paginated results with configurable size.\n\nUpdated acceptance criteria:\n- Offset and cursor pagination both return correct items and metadata (has_next/prev and next/prev pointers). Invalid cursors/params yield 422 via centralized error mapping.\n- Range filters (year, difficulty, rating) reduce results correctly, enforce min ≤ max, and combine with other filters and pagination.\n- Sorting remains restricted to supported fields and order; invalid sort rejected with 422; ordering is stable and deterministic across pages.\n- Specialized endpoints return correctly ordered results: popular by views, top-rated by rating, recent by created_at; artist/genre endpoints paginate correctly.\n- Bulk update/delete are atomic; partial failures roll back and return structured errors.\n- Filter options endpoint returns distinct genres, artists, albums, and years, scoped appropriately.\n- Listing and specialized queries execute within a bounded number of queries and produce accurate counts; cursor mode avoids unnecessary full COUNT scans.\n</info added on 2025-10-04T14:07:04.454Z>",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2025-10-04T14:07:09.051Z"
          },
          {
            "id": 6,
            "title": "Implement Authorization Hooks (Owner/Admin Ready)",
            "description": "Add authorization checks for create, read, update, and delete actions using JWT and role/ownership rules.",
            "dependencies": [
              "6.2",
              "6.3",
              "6.4"
            ],
            "details": "Auth model and rules:\n- Authentication: use JWT; user extracted from token; assume user.is_admin boolean is available.\n- Create: authenticated users only; owner_id set to current user id.\n- Read single: public songs accessible to anyone; private songs (is_public=false) only to owner or admin -> otherwise 403.\n- List: anonymous users see only public songs; authenticated users by default see public songs; support scope filter: mine (only their songs), public (only is_public=true), all (admin only, else 403).\n- Update/Delete: only owner or admin may modify/delete; enforce both at endpoint decorator/middleware and in service layer.\nImplementation:\n- Authorization decorator/util (e.g., can_manage_song) and checks inside service methods as defense in depth.\n- Ensure forbidden reasons are mapped to 403 via error handler.\nAcceptance criteria:\n- Unauthorized access to protected endpoints returns 401; insufficient privileges return 403.\n- Owners can update/delete their songs; non-owners cannot.\n- Admin can manage any song.\n- List endpoint enforces scope semantics as specified.\n<info added on 2025-10-04T14:13:31.066Z>\nEnhanced authorization implementation and integrations:\n- Added auth_decorators.py with AuthorizationManager and decorators/utilities: require_auth, require_owner, require_admin, require_permission, require_role, ResourceProtector, SongProtector. Applied to all song endpoints and admin routes; service layer mirrors checks for defense in depth.\n- Extended user model with role (user/moderator/admin), is_active/is_admin/is_moderator flags, permissions JSON, profile fields (bio, avatar_url, website_url), and helpers: has_role(), has_permission(), can_read/write/delete_resource(), update_role(), add_permission(), remove_permission(). Admins inherit all permissions; role-based defaults provided.\n- Extended song model with is_public, is_featured, is_flagged, flagged_reason, moderated_by, moderated_at, rating_count, and helpers: can_be_viewed_by(), can_be_edited_by(), can_be_deleted_by(), flag_song(), unflag_song(), make_public(), set_featured().\n- Introduced admin.py routes (admin only unless noted): /admin/users (list with pagination/filtering), /admin/users/{id}/role, /admin/users/{id}/activate, /admin/users/{id}/stats, /admin/users/{id}/promote, /admin/system/stats, /admin/moderation (moderation queue; moderators with moderate_songs permission or admins).\n- Enhanced songs.py routing with role/permission-aware access: per-song visibility filtering; owner_or_admin resource protection for write operations; new endpoints /songs/moderation (flagged songs; moderators/admins) and /songs/{id}/feature (admin only). Anonymous users see only public, unflagged songs; moderators see flagged content for review.\n- Created user_service.py for admin operations: role and permission management, account activation/deactivation, user statistics aggregation; all operations gated by admin or required permissions.\n- Added security audit logging for authorization decisions and admin/moderation actions.\n\nAdditional acceptance criteria:\n- Moderators with moderate_songs can list/review flagged songs and update moderation state; other users receive 403.\n- Admin-only routes require admin role; all admin actions are logged.\n- Scope filtering on list: mine (owner only), public (is_public=true), all (admin only). Flagged items are excluded from public/mine results unless user has moderate_songs.\n- Song visibility: public songs visible to everyone; private or flagged songs require owner, admin, or appropriate permission; failures return 403.\n- All protected endpoints require valid JWT; missing/invalid tokens return 401; permission/role failures return 403.\n</info added on 2025-10-04T14:13:31.066Z>",
            "status": "done",
            "testStrategy": "",
            "parentId": "undefined",
            "updatedAt": "2025-10-04T14:13:34.614Z"
          },
          {
            "id": 7,
            "title": "Write Unit/Integration Tests and Test Fixtures",
            "description": "Create fixtures and comprehensive tests covering CRUD, validation, pagination/filtering/sorting, and authorization.",
            "dependencies": [
              "6.1",
              "6.2",
              "6.3",
              "6.4",
              "6.5",
              "6.6"
            ],
            "details": "Fixtures:\n- Users: admin, owner, other_user; JWT helpers.\n- Songs: factories to create public/private songs for different owners.\n- Database/session: transactional test DB with rollback between tests.\nTests (examples, not exhaustive):\n- Create: 201 on valid input; body matches SongOut; 422 on invalid fields; owner_id set to actor.\n- Read single: 200 for public; 403 for private when not owner/admin; 404 when not found.\n- List: correct pagination meta; sorting correctness; case-insensitive title/artist filtering; scope behavior for anonymous/auth/admin.\n- Update: 200 with updated fields; 403 for non-owner; 422 for invalid update; immutable fields not changeable.\n- Delete: 204 success; subsequent get returns 404; 403 for non-owner.\n- Error mapping: verify 400, 401, 403, 404, 409, 422 responses with standardized error envelope.\n- Data integrity: verify updated_at changes on update; cascades or association cleanup on delete; no N+1 queries on list.\nAcceptance criteria:\n- All tests pass locally and in CI; coverage >= 80% for service and endpoints; tests assert both payload shape and HTTP codes.",
            "status": "pending",
            "testStrategy": "",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-10-04T14:13:34.614Z"
      },
      {
        "id": "7",
        "title": "Basic Search Functionality",
        "description": "Implement simple text-based search for songs by title and artist.",
        "details": "Use PostgreSQL full-text search capabilities to implement search functionality. Create API endpoints to handle search queries.",
        "testStrategy": "Test search functionality with various queries. Validate results against expected outcomes.",
        "priority": "medium",
        "dependencies": [
          "6"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Add PostgreSQL full-text search vector and GIN index for Songs",
            "description": "Create a tsvector search column for the Songs table combining title and artist, and index it to enable fast full-text search.",
            "dependencies": [],
            "details": "Implementation approach (Alembic migration + SQLAlchemy):\n1) Create an Alembic migration that:\n   - Ensures required extensions exist (optional but recommended):\n     - op.execute(\"CREATE EXTENSION IF NOT EXISTS pg_trgm\")  // optional, not strictly needed for FTS\n     - op.execute(\"CREATE EXTENSION IF NOT EXISTS unaccent\")  // optional if you want diacritic-insensitive search\n   - Adds a STORED generated column (PostgreSQL 12+):\n     op.execute(\"\"\"\n       ALTER TABLE songs\n       ADD COLUMN search_vector tsvector GENERATED ALWAYS AS (\n         setweight(to_tsvector('simple', coalesce(title, '')), 'A') ||\n         setweight(to_tsvector('simple', coalesce(artist, '')), 'B')\n       ) STORED\n     \"\"\");\n     // Use 'simple' config to avoid stemming of names; switch to 'english' if desired.\n   - Creates a GIN index on search_vector:\n     op.execute(\"CREATE INDEX IF NOT EXISTS idx_songs_search_vector ON songs USING GIN (search_vector)\");\n   - If STORED generated columns are not available in your environment, fall back to:\n     - Add a plain tsvector column search_vector\n     - Backfill: UPDATE songs SET search_vector = setweight(to_tsvector('simple', coalesce(title, '')), 'A') || setweight(to_tsvector('simple', coalesce(artist, '')), 'B');\n     - Add trigger to keep it updated:\n       op.execute(\"CREATE FUNCTION songs_search_vector_update() RETURNS trigger LANGUAGE plpgsql AS $$ BEGIN NEW.search_vector := setweight(to_tsvector('simple', coalesce(NEW.title, '')), 'A') || setweight(to_tsvector('simple', coalesce(NEW.artist, '')), 'B'); RETURN NEW; END $$;\");\n       op.execute(\"CREATE TRIGGER trg_songs_search_vector BEFORE INSERT OR UPDATE OF title, artist ON songs FOR EACH ROW EXECUTE FUNCTION songs_search_vector_update();\");\n     - Create the same GIN index as above.\n2) Update the SQLAlchemy model (if needed) to include the search_vector column as a deferred/read-only column for query use; it doesn’t need to be exposed via API.\n3) Run migration and verify the index exists.",
            "status": "pending",
            "testStrategy": "Post-migration verification: SELECT to_regclass('public.idx_songs_search_vector') should not be NULL. Seed a few songs, run an EXPLAIN on a sample FTS query (WHERE search_vector @@ websearch_to_tsquery('simple', 'beatles')) and confirm the GIN index is used.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement search service/repository using PostgreSQL full-text search",
            "description": "Create a backend function that executes ranked full-text searches over Songs by title and artist, with pagination.",
            "dependencies": [
              "7.1"
            ],
            "details": "Implementation approach (Flask + SQLAlchemy):\n1) Add a function search_songs(q: str, limit: int = 20, offset: int = 0) -> list[Song], and optionally return a tuple (results, count_estimate) if you decide to include counts later.\n2) Build a tsquery with websearch_to_tsquery('simple', :q) to support AND/OR, quotes, and prefix via trailing '*'.\n3) Query pattern (SQLAlchemy pseudocode):\n   ts_query = func.websearch_to_tsquery('simple', bindparam('q'))\n   rank = func.ts_rank_cd(Song.search_vector, ts_query)\n   stmt = (\n     sa.select(Song, rank.label('rank'))\n       .where(Song.search_vector.op('@@')(ts_query))\n       .order_by(sa.desc(rank), Song.title.asc(), Song.id.asc())\n       .limit(sa.bindparam('limit'))\n       .offset(sa.bindparam('offset'))\n   )\n   Use bound params to prevent SQL injection.\n4) Enforce parameter caps: limit min=1, max=50; offset >= 0.\n5) Consider weighting already encoded in search_vector; rank with ts_rank_cd is sufficient. If you did not weight in the vector, pass weights to ts_rank_cd as needed.\n6) Return a lightweight DTO per song (id, title, artist, and optionally rank) for the API layer.",
            "status": "pending",
            "testStrategy": "Unit tests against a test DB: seed songs with overlapping words across title and artist to verify ranking (title-weighted > artist-weighted). Test: simple term, multi-term AND/OR, quoted phrases, trailing '*' for prefix. Verify pagination and deterministic ordering for ties.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Define API contract and validate request/response for song search",
            "description": "Specify and validate the search endpoint contract, including required query parameter q and pagination parameters, with clear error handling.",
            "dependencies": [
              "7.2"
            ],
            "details": "Implementation approach:\n1) Endpoint: GET /songs/search\n2) Query parameters:\n   - q (required, string, 1..200 chars)\n   - limit (optional, int, default 20, 1..50)\n   - offset (optional, int, default 0, >=0)\n3) Response body (200):\n   {\n     \"results\": [{\"id\": ..., \"title\": \"...\", \"artist\": \"...\", \"rank\": 0.0}],\n     \"limit\": 20,\n     \"offset\": 0,\n     \"count\": null\n   }\n   Note: count can be omitted or null for simplicity; add later if needed.\n4) Errors:\n   - 400 for missing/empty q or invalid params (non-integer limit/offset, out of range)\n5) Validation: Use Marshmallow or Pydantic-like schema for parsing and validating query params; clamp/cap values; trim q; reject queries that are whitespace-only.\n6) Document in OpenAPI/Swagger (path, parameters, responses).",
            "status": "pending",
            "testStrategy": "Contract tests: validate 400 on invalid q, negative offset, excessive limit. Validate schema of 200 response. Include an OpenAPI validation step if available.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement GET /songs/search endpoint in Flask",
            "description": "Create the Flask route/controller that validates input, invokes the search service, and returns JSON results.",
            "dependencies": [
              "7.3"
            ],
            "details": "Implementation approach:\n1) Add route in the songs blueprint/module: @bp.get('/songs/search').\n2) Parse and validate query params using the schema from 7.3. On validation error, return 400 with message and details.\n3) Call search_songs(q, limit, offset) from 7.2. Map returned rows to JSON objects (id, title, artist, optional rank rounded to 4 decimals).\n4) Return 200 JSON: {results, limit, offset}.\n5) Logging: log query terms and pagination (without PII). Add basic timing metrics to observe performance.\n6) Security/performance safeguards: enforce cap on limit, and short-circuit empty q. No authentication required unless product requires it; if auth is required later, add @jwt_required(optional=True) as needed without altering core logic.",
            "status": "pending",
            "testStrategy": "Integration tests with Flask test client: seed a few songs and hit /songs/search. Verify 200 path returns expected ordering, 400 on invalid input, pagination behavior, and absence of server errors. Optionally test JSON serialization and CORS headers if applicable.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "End-to-end search tests and performance smoke checks",
            "description": "Verify correctness across realistic datasets and ensure the GIN index is used so queries remain fast.",
            "dependencies": [
              "7.4"
            ],
            "details": "Implementation approach:\n1) E2E tests (pytest): spin up a test Postgres with migrations applied. Seed 50–100 songs with diverse titles/artists.\n2) Correctness scenarios: search by exact title word, artist name, multi-word queries, quoted phrases, punctuation, case-insensitivity, prefix (provide trailing '*'). Validate that top results include expected songs and ranking is sensible.\n3) Pagination scenarios: limit/offset correctness and stable ordering across pages.\n4) Performance smoke: ensure cold query returns in <150 ms on test hardware and <30 ms warm (adjust thresholds per environment). Use EXPLAIN ANALYZE in a diagnostic test (not part of CI by default) to confirm GIN index usage.\n5) Regression harness: add tests for edge cases (empty results, very long q rejected, high Unicode).",
            "status": "pending",
            "testStrategy": "Run the test suite in CI against a Postgres service. Optionally collect EXPLAIN plans and log them for manual inspection. Use a seeded dataset to assert deterministic outcomes.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "8",
        "title": "Core Song Display",
        "description": "Develop the frontend component for displaying songs with basic chord/lyric formatting.",
        "details": "Create a song display component that formats chords and lyrics. Ensure responsive design and compatibility across devices.",
        "testStrategy": "Test display on different devices and screen sizes. Verify formatting accuracy and responsiveness.",
        "priority": "medium",
        "dependencies": [
          "5",
          "6"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "9",
        "title": "User Preferences Management",
        "description": "Implement storage and retrieval of user preferences for display settings.",
        "details": "Create API endpoints to save and retrieve user preferences. Update the frontend to allow users to customize their display settings.",
        "testStrategy": "Test preference changes and persistence across sessions. Verify API interactions and data consistency.",
        "priority": "medium",
        "dependencies": [
          "4",
          "5"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "10",
        "title": "API Integration for Song Import",
        "description": "Integrate with external APIs (Ultimate Guitar, Songsterr) for song import.",
        "details": "Develop backend services to fetch and import songs from external APIs. Handle API authentication and rate limits.",
        "testStrategy": "Test API integration with mock and live data. Validate imported data against source APIs.",
        "priority": "medium",
        "dependencies": [
          "6",
          "7"
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-10-04T14:13:34.621Z",
      "taskCount": 10,
      "completedCount": 5,
      "tags": [
        "master"
      ]
    }
  }
}